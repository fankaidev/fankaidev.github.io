---
layout: single
title:  What is "Object-Oriented Programming" 摘录和笔记（草稿）
---

原文是Stroustrup早期介绍C++设计的文章[What is "Object-Oriented Programming"](http://www.stroustrup.com/whatis.pdf)，尝试翻译摘录一些片段，同时写一点自己的理解。

# 摘要

“面向对象编程”(Object-Oriented Programming)和“数据抽象”(Data Abstraction)已经成为常用术语。不幸的是大家依然很难对他们的定义达成共识。本文尝试给出非正式的定义，这些定义在Ada,C++,Modula-2,Simula和Smalltalk这些语言的上下文里看起来是合理的。总的想法是把”支持数据抽象“等同于定义和使用新类型的能力，把”支持面向对象编程“等同于表达类型层次的能力。本文会讨论在通用语言中支持这些编程风格需要哪些特性。文中的展示基于C++，但不会限于这个语言的特性。

# 1 介绍

不是所有的语言都是面向对象的。APL,Ada,Clu,C++,LOOPS和Smalltalk都有人宣称是面向对象的编程语言。我还听说了基于C,Pascal,Modula-2和CHILL等语言的面向对象设计的讨论。或许还有人支持在Fortran和Cobol上进行面向对象开发？我相信一定有的。“面向对象编程”在很多场景下变成了“好”的高科技同义词，当你查看行业期刊里的各种讨论，你会看到各种类似以下三段论的论证：
* Ada是好的
* 面向对象是好的
* 所以Ada是面向对象的

本文提出了一个观点，即在通用语言中，“面向对象”应当表示什么意义。
* 2 区分“面向对象编程”和“数据抽象”以及其他的编程风格，阐述支持各种编程风格所必需的各种机制
* 3 阐述了使“数据抽象”更加高效所需的特性
* 4 讨论了支持“面向对象编程”所需的设施
* 5 阐述了传统硬件架构和操作系统对于“数据抽象”和“面向对象编程”的一些限制

文字的例子使用了C++，既是为了介绍C++，也是因为C++是少数几种在传统编程范式之外还支持数据抽象和面向对象编程的语言。并发问题和对特定高级语言结构(specific higher-level language constructs)的硬件支持不在本文讨论范围。

# 2 各种编程范式 (Programming Paradigms)

面向对象编程是一种编程技术，也即一种能够对一些问题写出“好”代码的范式。要使得“面向对象编程语言”这个词有意义，它就必须表示这个编程语言提供了一些机制，可以很好的支持面向对象风格的编程。

需要注意一个重要的区别。要支持一种编程风格，一个编程语言必须可以方便（简单、安全、高效）的使用这种编程风格。如果需要超常的努力和技巧才能写出这种风格的代码，那就称不上是“支持(support)”，顶多算是“允许(enable)”。比如说，你也可以再Frotran里写结构化的程序，在C里写类型安全的程序，在Modula-2里使用数据抽象，但实现起来都会非常困难，因为这些语言并不“支持”这些技术。

支持一种其他语言没有的特性，并不一定让一个语言变得更好。有很多的例子恰恰相反。所以重点不是支持多少特性，而是其所支持的特性是否足以在期望的应用场景中使用期望的编程风格。

1. 这些特性必须是干净优雅的融合在语言中
1. 这些特性可以被组合使用，而不是给每个场景都设置新的特性
1. “虚假”特性和“特殊”特性（spurious and 'special purpose' features)越少越好
1. 这些特性在不使用的时候不能有明显的运行成本
1. 用户不需要了解所有的特性，而只需要了解代码中真正用到的那些特性

接下来我阐述一下几种编程风格和其所必需的语言机制。对这些机制的说明未必是详尽的。

## 2.1 过程式编程（Procedural Programming)

*fk: 一种定义是，过程式编程是结构化编程的子集，结构化编程是命令式编程的子集。不过文中似乎是当做命令式编程的同义词。*

这是最早（大概也是最常用的）编程范式：

```
确定好需要的步骤；
使用最好的算法。
```

关注点是过程的设计，也就是执行所需计算的算法。为了支持这个范式，编程语言需要支持函数传参和函数返回值。对这些语言的讨论充斥的是如何实现传参、如何区分不同的参数、如果区分不同的函数（procedure, routine, macro ...)等等。Fortran是最早的这类语言，Algol60,Algol68,C和Pascal这些后来的发明也是同一个流派。

这个范式中中，“好风格”的一个典型例子是求根。输入一个参数，干净利落的输出一个结果。其实现就是执行一些广为人知的数学计算。

```
    double sqrt(double arg)
    {
        // the code for calculating a square root
    }

    void some_function()
    {
        double root2 = sqrt(2);
        // ...
    }
```

从程序组织的角度来看，函数的作用就是给各个算法确定一个顺序。

## 2.2 数据隐藏 (Data Hiding)

近些年来，编程语言设计的重点从过程的设计转向了对数据的组织。部分反映了程序规模的扩大。一组相关联的过程以及他们操作的数据常常被称为“模块(module)”。这种编程范式也就成为了：
```
    决定需要什么模块；
    把程序按照模块来划分，使得数据隐藏在各个模块之中。
```

这种范式也常常被称为“数据隐藏原则”。如果不需要把过程和数据的分组，那么过程式编程足够了。尤其是，设计“好过程”的那些技术现在应用到了各个模块内部的过程。最常用的例子是定义一个stack的模块。

*省略。fk: 主要是举了一个stack实现的例子，通过单独定义一个文件来暴露对外操作的接口，但是隐藏内部的数据。*

Pascal没有令人满意的方式来实现这样的分组机制：要隐藏一个命名的唯一方式是定义在一个过程（Procedure）内部。这会导致各种奇怪的嵌套函数和对全局变量的过度依赖。

C做的好了一些，如上述例子，可以通过把函数和数据定义在同一个源文件中来实现分组。程序员可以控制哪些命名是可以被外部所见（static的变量是外部不可见的）。因此在C语言中，是可以实现一定程度的模块化。但是现在还没有通用的范式来使用这些技术，而且对于static声明的依赖实在太底层了。

Pascal的一个继承者，Modula-2，走了更远了一步。它规范了模块的定义，把它作为了基础的语言结构(language construct)。它提供了明确的模块声明，显式的命名作用域控制，模块初始化机制，以及一组被广为知晓且接受的用法。

总结上述C和Modula-2的区别，可以说C只是“允许（enable）”把程序拆分到模块中，而Modula-2“支持（support）”这种技巧。

## 2.3 数据抽象 (Data Abstraction)

*省略。fk: 这一节讨论了数据抽象。还是以stack为例,及时有了模块，用户面对的只是一组函数，在操作中也总是要带上id。完整的抽象，是希望像使用原生类型一样能够定义一个stack，并进行各种操作。从而引出了用户自定义类型（class）以及操作符重载的需求。一般情况下，用自定义类型来表达模块（操作+数据）是最自然的。*

## 2.4 数据抽象的问题

*省略。fk: 抽象数据类型对外提供的是一个黑盒，这导致要扩展其能力是比较困难的，除非修改源文件。使用了shape的例子，说明draw方法很难扩展。*

## 2.5 面向对象编程 (Object-Oriented Programming)

问题在于没有区分不同shape里的共性(都有颜色，可以draw，等等）和特性（圆有半径，有其特殊的绘制方法）。能够表达和利用这些区别的编程语言就是面向对象编程语言，而其他的语言不是。

*省略。fk: 接下来举了继承和多态的例子来解决shape绘制的问题。*

编程范式总结为
```
    决定你要的类；
    为每个类提供一套操作；
    通过继承来表达共性
```

如果程序中并没有太多的共性，那么数据抽象（也就是模块化）已经足够了。有多少需要通过继承和虚函数来表达的共性，是一个特定领域是否适用于面向对象编程的石蕊试验(*fk:立见分晓的检验办法*）。

在系统中寻找共性绝不容易。系统的设计方式也会影响有多少共性可以被利用。在设计的时候，需要积极的寻找共性，要么把一些类设计成为其他类的组成部分，要么把不同类中相似的部分抽取到一个父类中。

*fk:这里其实提到了组合和继承都可以是使用共性的合理方式。*

# 3 对数据抽象的支持

对数据抽象的基本支持，包括了对数据类型定义一组操作，并且提供对这些操作的访问控制。除此之外，程序员也马上会要求对于类型的定义和使用提供更加便利的支持。操作符重载就是一个这样的例子。

## 3.1 初始化和释放 (Initialization and Cleanup)

*省略。fk：对于自定义类型，需要一定的机制来完成构造和清理。C++不提供垃圾回收，而是通过构造和析构函数来自动的进行构造和清理*

## 3.2 赋值和初始化 (Assignment and Initialization)

*省略。fk：需要定义类型的初始化和赋值操作，C++也是通过构造函数来完成*

## 3.3 参数化类型 (Parameterized Types)

*省略。fk：需要表达一个类可以应用于多个类型。C++当时还不提供模板。*

## 3.4 异常处理 (Exception Handling)

*省略。fk：需要提供异常处理机制。当时C++也还没有*

## 3.5 强制转换 (Coercions)

*省略*

## 3.6 迭代器 (Iterators)

*省略。fk：提供一致的控制流，比如循环，因此可以通过迭代器来实现。当时C++还没有STL，文中讨论了几种可能的实现方式。 *

## 3.7 实现中的问题 (Implementation Issues)

*省略。fk：讨论了要对上述机制良好的支持，需要编译器、连接器、库等各个方面的工作*

# 4 对面向对象编程的支持

对于面向对象编程的基本支持包括了支持继承的类机制和在运行时根据实际类型调用方法（多态）的机制。对成员函数的调用机制是关键。对数据抽象的支持也很重要。对这两种技术的成功支持都取决于类型系统的设计及其易用性、灵活性和效率。相对于只使用数据抽象技术的设计，面向对象编程使得用户自定义类型更加灵活和通用。

## 4.1 调用机制 (Calling Mechanisms)

*省略。fk：讨论了普通函数和虚函数。以及对于类型的early-binding和late-binding（比如smalltalk），后者必须在运行期检查类型。*

## 4.2 类型检查 (Type Checking)

*省略。fk：讨论了静态类型检查和动态类型检查*

## 4.3 继承 (Inheritance)

## 4.4 多继承 (Multiple Inheritance)

## 4.5 封装 (Encapsulation)

## 4.6 实现中的问题 (Implementation Issues)

# 5 限制 (Limits to Perfection)

# 6 总结

面向对象编程是指使用继承来进行编程。数据抽象是指使用用户自定义类型来进行编程。除了少数例外，面向对象编程可以并且应该包含数据抽象。这些技术需要恰当的实现来保证高效。数据抽象一般需要语言特性的支持，而面向对象编程还需要编程环境的支持。为了保持通用，支持数据抽象或者面向对象编程的语言必须高效的利用传统硬件。

